package parser;

import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class Parser extends beaver.Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short LPAREN = 2;
		static public final short LBRACKET = 3;
		static public final short MINUS = 4;
		static public final short STRING_LITERAL = 5;
		static public final short INT_LITERAL = 6;
		static public final short TRUE = 7;
		static public final short FALSE = 8;
		static public final short RCURLY = 9;
		static public final short RPAREN = 10;
		static public final short BOOLEAN = 11;
		static public final short VOID = 12;
		static public final short INT = 13;
		static public final short LCURLY = 14;
		static public final short SEMICOLON = 15;
		static public final short COMMA = 16;
		static public final short IF = 17;
		static public final short WHILE = 18;
		static public final short BREAK = 19;
		static public final short RETURN = 20;
		static public final short RBRACKET = 21;
		static public final short PUBLIC = 22;
		static public final short EQL = 23;
		static public final short IMPORT = 24;
		static public final short TIMES = 25;
		static public final short DIV = 26;
		static public final short MOD = 27;
		static public final short PLUS = 28;
		static public final short TYPE = 29;
		static public final short MODULE = 30;
		static public final short ELSE = 31;
		static public final short EQEQ = 32;
		static public final short NEQ = 33;
		static public final short LEQ = 34;
		static public final short GEQ = 35;
		static public final short LT = 36;
		static public final short GT = 37;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pDLcTq55KK$cOIm4s41J44f6h8XZIGbX12Ix8X2Gb1GY10096YKXGLKR40Dkoe$E7untF" +
		"m77vui86AWWL5nTuRHCM2YbA2Y4OquFMRjo#xixEPtQp77#wURsxxxdrltjnvRm1p5UPWB2" +
		"fnFkPYFXPW9efnDKPZ3DAm4jSY5RtG6ttG5$rmDiv19xJ7QKZ2wJ2H4dUk9v0hcv4P8$SiH" +
		"svqzg2us8FZOkSvsDTXAHQY0XTW7XPZYVo4YLY5wt431Y01YSZ64EIZe1NUk21ldVpfniCz" +
		"g6lXoPwel7R1UXsYyKI2zKv6vJK7UN$Xp20lSdMcgjM9z5$iuizL$gxeXYcjH8Ufw8MjH4Q" +
		"wr2joyLUx#AUx#2zH$lCSwz09oRh3ksCKiwh2ilmH$9xI4E6BPLyMar4UDkuoU5KlNeuhi1" +
		"nNOWMkSiniVDnpYDUU43PU9tJKgxGMjwYvhPMVqPcMJmu4#aYEwtuAM3#YFrR3XtISWIxeW" +
		"TjrNZrcONRWIivjAENgrCWUrA2774C9KOURC1atAjoA3DR8GWu6ubmCnN3obs442b76zt0Q" +
		"QkKBp6166IRX8Yp2fV8vrk0Q#Gqtow#u0tVYBjoDUt4Vrk5#LihWsvF9UjcicCkQWrXrC3j" +
		"$AFjoED$zVDOkO2SMiXUiRXdBjxY8kq79lywjZZlt$yCskEjRUrmxdW8T#Fmzj9BP0ntP3m" +
		"RHXS#sA$UEI5vgaDUTbXkl6pkeXPSIbJS#oFD4vQ6DF8#D5xeFjzM9rv$4gbMkqOd$sJZn#" +
		"fth4EhI2kuuaLbEVWNlpEcBPIV6P8IFsqltOk3qJUCkaXunitZd4AyTFbvebGmzDuFFr#0$" +
		"8TX7ILe6hbQqZ54lTr6JFTvRv$NWTqvFVVKmwkUO9dCjJX9tsoJACjReh63mdR16i1XzrTN" +
		"FrV7oNqf$CUqaNZlJIk7VibDuZdWfozLpIkNzU2czV0V7yyrOluON4VcROXFn0F4GiPNOIn" +
		"mZTXD7Y0RY9D4860PWzYNIYH546drPZ9qYDb3FiUhIdqtqehAJSZJHp$AxWV5XHARMIm8Ic" +
		"wbFrhuPhBsHieR6nvHZA0$es2p67gQSIgDP#wO4fB6QUctaU7YGiIsQiutOGLufvIxA3Chz" +
		"EdR8DiTvj8zJrccxN7Dut#PixIiYvj3NJ3bJ#xAYtRjZ7HA8wNgEswdNssB9nC8srfdli2S" +
		"uR3#nYF0Hx0Tp2J7DmLb1p2MM4ujj$fN4Kc91YuzzTDYsjXjeDzXY9$GwLMgvJykDeHpZg8" +
		"tVOFFxTKtkvaPTM#xTYPRnRJLDNJDNIxyjraNxwXqvVTpgM$qVa6OYzKM1lhTwodfFZ4sQq" +
		"#Z8oOkiWuCXtUolUSLMFsgVhwttp5#JhLQEO#pgjjQ9FKxmdKrsZXD7ZNmzv$NGFpabJKes" +
		"XU3yoGcR$eiSbKOv8eVba1nKdX#8HvJsVLZM$g3s7V6jqhwHh#Kh#LBUeFwPS7UHZuWFYVU" +
		"9j#HDAqBj4#9JfRsiQ#oHlVA1l2lloDlodhmkk#KrULLUaLqg#fAwxfGNbNn1dfVdP8Tibs" +
		"Vb6TacJzEtJxRA5db27fV7vD6mUVvExrD1wqdvGw#BjL$NyZkoFNVnHBMJZ#5f409uEdbuI" +
		"Xa4U7wOwjIPGBsSvqGvvN36t512RWav5UHMKEPHvXCZU18My0GPoNWXxKBAKSGWvbYeebv5" +
		"Vh4wYy2l6fFV60ayEKqYKNrj3AOzKC7WgPsWJkvI6tpa#YW7H44cQsKnDvkwXHpgVaeBbIu" +
		"OnvmYhjSGTM87CDI6OQmnwHybVdVt");

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN9 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 9];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	// turn off automated error recovery
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws java.io.IOException, Exception {
		super.recoverFromError(new Symbol(0), in);
	}

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			RETURN6,	// [0] Module = MODULE ID LCURLY ImportStmt DeclarationStmt RCURLY; returns 'RCURLY' although none is marked
			RETURN4,	// [1] ImportStmt = IMPORT ID SEMICOLON ImportStmt; returns 'ImportStmt' although none is marked
			Action.NONE,  	// [2] ImportStmt = 
			RETURN2,	// [3] DeclarationStmt = FunctionDeclarationStmt DeclarationStmt; returns 'DeclarationStmt' although none is marked
			RETURN2,	// [4] DeclarationStmt = FieldDeclarationStmt DeclarationStmt; returns 'DeclarationStmt' although none is marked
			RETURN2,	// [5] DeclarationStmt = TypeDeclarationStmt DeclarationStmt; returns 'DeclarationStmt' although none is marked
			Action.NONE,  	// [6] DeclarationStmt = 
			RETURN9,	// [7] FunctionDeclarationStmt = Accessibility TypeName ID LPAREN ParameterlistStmt RPAREN LCURLY StatementList RCURLY; returns 'RCURLY' although none is marked
			Action.RETURN,	// [8] Accessibility = PUBLIC
			Action.NONE,  	// [9] Accessibility = 
			RETURN2,	// [10] ParameterStmt = TypeName ID; returns 'ID' although none is marked
			RETURN2,	// [11] ParameterlistStmt = ParameterStmt ParameterlistStmtTail; returns 'ParameterlistStmtTail' although none is marked
			Action.NONE,  	// [12] ParameterlistStmt = 
			RETURN3,	// [13] ParameterlistStmtTail = COMMA ParameterStmt ParameterlistStmtTail; returns 'ParameterlistStmtTail' although none is marked
			Action.NONE,  	// [14] ParameterlistStmtTail = 
			Action.RETURN,	// [15] Statement = LocalVariableDeclaration
			Action.RETURN,	// [16] Statement = StatementBlock
			Action.RETURN,	// [17] Statement = IfStmt
			Action.RETURN,	// [18] Statement = WhileStmt
			Action.RETURN,	// [19] Statement = BreakStmt
			Action.RETURN,	// [20] Statement = ReturnStmt
			Action.RETURN,	// [21] Statement = ExprStmt
			RETURN2,	// [22] StatementList = Statement StatementListTail; returns 'StatementListTail' although none is marked
			Action.NONE,  	// [23] StatementList = 
			RETURN3,	// [24] StatementListTail = COMMA Statement StatementListTail; returns 'StatementListTail' although none is marked
			Action.NONE,  	// [25] StatementListTail = 
			RETURN3,	// [26] LocalVariableDeclaration = TypeName ID SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN3,	// [27] StatementBlock = LCURLY StatementList RCURLY; returns 'RCURLY' although none is marked
			RETURN7,	// [28] IfStmt = IF LPAREN Expr RPAREN Statement ELSE Statement; returns 'Statement' although none is marked
			RETURN5,	// [29] WhileStmt = WHILE LPAREN Expr RPAREN Statement; returns 'Statement' although none is marked
			RETURN2,	// [30] BreakStmt = BREAK SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN3,	// [31] ReturnStmt = RETURN Expr SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN2,	// [32] ReturnStmt = RETURN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN2,	// [33] ExprStmt = Expr SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.RETURN,	// [34] Expr = Assignment
			Action.RETURN,	// [35] Expr = RHSExpr
			RETURN2,	// [36] ExprList = Expr ExprListTail; returns 'ExprListTail' although none is marked
			Action.NONE,  	// [37] ExprList = 
			RETURN3,	// [38] ExprListTail = COMMA Expr ExprListTail; returns 'ExprListTail' although none is marked
			Action.NONE,  	// [39] ExprListTail = 
			RETURN2,	// [40] NonEmptyExprList = Expr ExprListTail; returns 'ExprListTail' although none is marked
			RETURN3,	// [41] Assignment = LHSExpr EQL Expr; returns 'Expr' although none is marked
			RETURN2,	// [42] LHSExpr = ID BOOLEAN; returns 'BOOLEAN' although none is marked
			RETURN4,	// [43] LHSExpr = LHSExpr LBRACKET Expr RBRACKET; returns 'RBRACKET' although none is marked
			Action.RETURN,	// [44] RHSExpr = ArithmeticExpr
			RETURN3,	// [45] RHSExpr = ArithmeticExpr ComparisionOperator ArithmeticExpr; returns 'ArithmeticExpr' although none is marked
			new Action() {	// [46] ArithmeticExpr = ArithmeticExpr AdditiveOperator Term
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [47] ArithmeticExpr = Term
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [48] Term = Term MultiplicativeOperator Factor
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [49] Term = Factor
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [50] MultiplicativeOperator = TIMES
			Action.RETURN,	// [51] MultiplicativeOperator = DIV
			Action.RETURN,	// [52] MultiplicativeOperator = MOD
			RETURN2,	// [53] Factor = MINUS Factor; returns 'Factor' although none is marked
			Action.RETURN,	// [54] Factor = PrimaryExpr
			Action.RETURN,	// [55] PrimaryExpr = LHSExpr
			Action.RETURN,	// [56] PrimaryExpr = FunctionCall
			Action.RETURN,	// [57] PrimaryExpr = ArrayExpr
			Action.RETURN,	// [58] PrimaryExpr = STRING_LITERAL
			Action.RETURN,	// [59] PrimaryExpr = INT_LITERAL
			Action.RETURN,	// [60] PrimaryExpr = BooleanLiteral
			Action.RETURN,	// [61] PrimaryExpr = ParenthesisedExpr
			RETURN4,	// [62] FunctionCall = ID LPAREN ExprList RPAREN; returns 'RPAREN' although none is marked
			RETURN3,	// [63] ArrayExpr = LBRACKET NonEmptyExprList RBRACKET; returns 'RBRACKET' although none is marked
			Action.RETURN,	// [64] BooleanLiteral = TRUE
			Action.RETURN,	// [65] BooleanLiteral = FALSE
			RETURN3,	// [66] ParenthesisedExpr = LPAREN Expr RPAREN; returns 'RPAREN' although none is marked
			Action.RETURN,	// [67] AdditiveOperator = PLUS
			Action.RETURN,	// [68] AdditiveOperator = MINUS
			Action.RETURN,	// [69] ComparisionOperator = EQEQ
			Action.RETURN,	// [70] ComparisionOperator = NEQ
			Action.RETURN,	// [71] ComparisionOperator = LEQ
			Action.RETURN,	// [72] ComparisionOperator = GEQ
			Action.RETURN,	// [73] ComparisionOperator = LT
			Action.RETURN,	// [74] ComparisionOperator = GT
			RETURN4,	// [75] FieldDeclarationStmt = Accessibility TypeName ID SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN6,	// [76] TypeDeclarationStmt = Accessibility TYPE ID EQL STRING_LITERAL SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.RETURN,	// [77] TypeName = PrimitiveType
			Action.RETURN,	// [78] TypeName = ArrayType
			Action.RETURN,	// [79] TypeName = ID
			Action.RETURN,	// [80] PrimitiveType = VOID
			Action.RETURN,	// [81] PrimitiveType = INT
			Action.RETURN,	// [82] PrimitiveType = BOOLEAN
			RETURN3	// [83] ArrayType = TypeName LBRACKET RBRACKET; returns 'RBRACKET' although none is marked
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
